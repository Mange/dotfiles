#!/bin/sh
# vim:ft=sh:
set -e

# Prevent more than one instance from running at the same time, which is likely
# to happen in the case of rebases, etc. where a lot of commits are being made
# in a very short amount of time.
#
# Oldest invocation will win, which is not optimal, but it will sort itself out
# on the next time it runs.
[ -f .git/tags.lock ] && exit 0

unlock() {
  rm -f .git/tags.lock
}
trap 'unlock' EXIT
touch .git/tags.lock

# Generate Rust tags if project is a Rust crate and tooling is in place.
# Generate Ruby tags if project is a Ruby app/lib and tooling is in place.
if [ -f Cargo.toml ] && hash rusty-tags 2>/dev/null; then
  # Find source code of current toolchain if not already defined.
  if [ -z "$RUST_SRC_PATH" ] && hash rustc 2>/dev/null; then
    RUST_SRC_PATH=$(rustc --print sysroot)/lib/rustlib/src/rust/src/
    export RUST_SRC_PATH
  fi
  rusty-tags --quiet vi
elif [ -f Gemfile ] && hash ripper-tags 2>/dev/null; then
  trap 'unlock; rm -f .git/tags.$$' EXIT
  ripper-tags \
    -R --tag-relative \
    -f .git/tags.$$ \
    --exclude config/routes/
  mv .git/tags.$$ .git/tags
else
  # Generate normal ctags instead
  trap 'unlock; rm -f .git/tags.$$' EXIT
  ctags --tag-relative \
    -Rf.git/tags.$$ \
    --exclude=.git \
    --exclude=tmp \
    --exclude=build \
    --exclude=target \
    --languages=-javascript,sql
  mv .git/tags.$$ .git/tags
fi
