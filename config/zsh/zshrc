#!/bin/zsh
# vim: fdm=marker:

setopt extendedglob
zmodload zsh/datetime
autoload is-at-least
autoload -Uz add-zsh-hook

# Chain with true to avoid $? being false
[ -f "${XDG_CONFIG_HOME}/zsh/zshrc.before.local" ] && source "${XDG_CONFIG_HOME}/zsh/zshrc.before.local" || true

# {{{ Helper functions
command-exist() { whence $1 > /dev/null; }

alias-if-exist() {
  local old_command=$1
  shift
  local new_command=$1

  if command-exist $new_command; then
    alias $old_command="$*"
  fi
}

try-source-plugin() {
  local path="/usr/share/zsh/plugins/${1}/${1}.zsh"
  if [[ -f "${path}" ]]; then
    source "${path}"
    return 0
  else
    return 1
  fi
}
# }}}
# {{{ umask
# I want my primary group to write to my files
# Why wouldn't I?
umask 002
# }}}
# {{{ ZLE and fzf
# Default:        *?_-.[]~=/&;!#$%^(){}<>
export WORDCHARS='*?[]~&;!#$%^(){}'

# Vim keys in shell
bindkey -d # Delete all existing keybinds
bindkey -v # Use vimkeys by default
KEYTIMEOUT=1 # 10ms delay for Escape key

# Delete EMACS-like bindings to retrain my muscle memory
# See info about how this works here: https://unix.stackexchange.com/a/320432
bindkey -s '^[OC' '\a' # → ?
bindkey -s '^[OD' '\a' # ← ?
bindkey -s '^[[C' '\a' # →
bindkey -s '^[[D' '\a' # ←
bindkey -s '^[OA' '\a' # Up ?
bindkey -s '^[OB' '\a' # Down ?
bindkey -s '^[[A' '\a' # Up
bindkey -s '^[[B' '\a' # Down
bindkey -s '^A' '\a'

# New line
bindkey -M viins '^J' self-insert

# Vim-like bindings
# Stolen from https://github.com/sharat87/zsh-vim-mode/blob/master/zsh-vim-mode.plugin.zsh

# Fix more vim-like bindings (instead of vi)
# vi bindings do not kill beyond the start of Insert mode (e.g. enter insert
# and press backspace and nothing happens)
bindkey "^W" backward-kill-word    # vi-backward-kill-word
bindkey "^H" backward-delete-char  # vi-backward-delete-char
bindkey "^U" backward-kill-line    # vi-kill-line
bindkey "^?" backward-delete-char  # vi-backward-delete-char

bindkey -M vicmd 'yy' vi-yank-whole-line
bindkey -M vicmd 'Y' vi-yank-eol

bindkey -M vicmd 'u' undo
bindkey -M vicmd '^R' redo

bindkey -M vicmd 'K' run-help

# Load editor support
autoload edit-command-line
zle -N edit-command-line
bindkey -M vicmd 'v' edit-command-line

# See extra bindkey calls under the Plugins section

if [ -d ~/.fzf ]; then
  source ~/.fzf/shell/completion.zsh 2> /dev/null
  source ~/.fzf/shell/key-bindings.zsh

  bindkey -M vicmd "/" fzf-history-widget
  bindkey "^P" fzf-file-widget
fi

# Use highlight to preview FZF files under CTRL+T
if command-exist highlight; then
  export FZF_CTRL_T_OPTS="--preview '(bat --style=numbers --color=always {} || cat {} || tree -C {}) 2> /dev/null | head -200'"
fi

# Use ripgrep to populate fzf
if command-exist rg; then
  export FZF_DEFAULT_COMMAND='rg --files --hidden --follow --glob "!.git/*"'
fi

# Outputs $1 when on insert mode and outputs $2 when on command mode.
# zle_mode_output "when insert" "when command"
function zle_mode_output {
  # Keymap could be empty sometimes; assume insert mode
  case $KEYMAP in
    ("vicmd") echo $2;;
    (*) echo $1
  esac
}

# Reset prompt on mode change
function zle-keymap-select {
  zle reset-prompt
}
zle -N zle-keymap-select

# }}}
# {{{ ls (Colors, etc.)
eval $(dircolors -b)

# Files that I don't have to pay attention to
export LS_COLORS="$LS_COLORS:*.nfo=90:*.sfv=90:*.srt=90:*.sub=90"
export ZLS_COLORS="${LS_COLORS}"

alias ls='ls --color=auto'
alias l='ls -l'

# Replace l with exa if exa is installed
if command-exist exa; then
  alias ls='exa --group-directories-first'
  alias l='exa --group-directories-first --long --color-scale --git'
fi

# }}}
# {{{ EDITOR
try-editor() {
  if command-exist $1; then
    EDITOR="$@"
  fi
}

try-editor nano
try-editor vi
try-editor vim
try-editor nvim

export VISUAL=$EDITOR

unset -f try-editor
# }}}
# {{{ Completions
# Activate completion system and do some basic settings

zmodload zsh/complist

# Use my custom completions too
fpath=("${XDG_CONFIG_HOME}/zsh/completion" $fpath)

autoload -U compinit && compinit -d "${XDG_CACHE_HOME}/zcompdump"

# Add AWS completions if aws is installed
if [[ -f ~/.local/bin/aws_zsh_completer.sh ]]; then
  source ~/.local/bin/aws_zsh_completer.sh
fi

# Find out what an alias stands for and complete like if it was the original command
# This gives me git completion for my git aliases, for example
setopt nocomplete_aliases

zstyle ':completion:*' cache-path "${XDG_CACHE_HOME}/zsh-completioncache"

# Use verbose completions (usually adds descriptions / context to matches)
zstyle ':completion:*' verbose yes

# Approximate when no matches can be found – corrects small errors
zstyle ':completion:*' completer _complete _approximate

# Environments to assume when autocompleting sudo
# In case I didn't already have all the sbin dirs in PATH, I would add them here
zstyle ':complete:sudo:' environ HOME="/root"

# Commands that should be completed like other commands
compdef run-changed-specs=rspec
compdef run-branch-specs=rspec

# Show completion group names
zstyle ':completion:*:descriptions' format "%d"
# }}}
# {{{ Named Directories
# Make certain paths into named directories ("~name" instead of "/path/to/name")

# namedir name [path]
namedir () {
  local target
  if [[ $2 == "" ]]; then
    target=$(pwd)
  else
    target=$2
  fi

  hash -d $1=$target
}

# Give all projects a name
if [ -d ~/Projects ]; then
  for dir in ~/Projects/*(/N); do
    namedir "$(basename $dir)" "$dir"
  done
fi
# }}}
# {{{ Navigation
# Navigation tricks and shortcuts

setopt auto_pushd
setopt pushd_ignore_dups

alias tree='tree -AC -I ".svn|.git|node_modules|bower_components"'
alias t='tree -L 3 --filelimit 50'

# Sort files by size and show human readable
alias fusage='ls -Ssrh'

# Enhanced cd:
#   * cd <path>/<file> go to <path>
cd () {
  if (( $# != 1 )); then
    builtin cd "$@"
  else
    if [[ -f "$1" ]]; then
      builtin cd "$1:h"
    else
      builtin cd "$1"
    fi
  fi
}

# Display contents of current directory when changing directories
function chpwd { exa --group-directories-first || ls }
# }}}
# {{{ History
export HISTSIZE=5000
export SAVEHIST=5000
export HISTFILE="${XDG_DATA_HOME}/zsh/history"

# don't replace history when process exits
setopt append_history
# remove old dups when added again
setopt hist_ignore_all_dups
# verify ! expansions
setopt hist_verify
# skip history entry if command starts with a space
setopt hist_ignore_space

# }}}
# {{{ Pager
# Pager settings (less, man, etc.)

# This makes man pages look cooler
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'

# Default less(1) options
# --Raw-control-chars :: Support ANSI color control chars
# --ignore-case       :: Smart case search (Ignore-case is normal case insensitive search)
export LESS="--Raw-control-chars --quit-if-one-screen --ignore-case"
# }}}
# {{{ Copy/Paste
if command-exist pbcopy; then
  alias copy=pbcopy
  alias paste=pbcopy
else
  alias copy='xsel --clipboard --input'
  alias paste='xsel --clipboard --output'

  # Hard to break some habits
  alias pbcopy=copy
  alias pbpaste=paste
fi

# cat foo.txt bar.txt CP
alias -g CP='| copy'
# }}}
# {{{ Command replacements / aliases for commands with non-standard names
# Colordiff
alias-if-exist diff colordiff
alias-if-exist ping prettyping --nolegend
# }}}
# {{{ Git settings and shortcuts
git_log_format='%C(bold blue)%h%Creset %C(bold)%s%Creset%C(auto)%d%n%C(dim white)%ad %C(nodim green)(%ar)%Creset - %an%C(yellow)%+N%n%Creset'

alias-if-exist git hub

alias checkout='git checkout'
alias master="git checkout master"

alias gadd='git add'
alias gco='git commit -v'
alias gpu='git push'
alias gb="git branch -v"
alias gba="git branch -va"
alias gbm="git branch -v --merged"

alias gm='git merge --no-ff'
alias gmo='git merge --no-ff @{upstream}'
alias gmm='git merge --no-ff master'

alias fixup='gco --fixup "$(git fshow)"'
alias gro='git rebase @{upstream}'
alias grm='git rebase master'
alias gri='git rebase -i'
alias grim='git rebase -i master'
alias grio='git rebase -i @{upstream}'

alias gf='git fetch --prune'
alias ff='git merge --ff-only'
alias ffm='git merge --ff-only master'
alias ffo='git merge --ff-only @{upstream}'
alias gup='gf && ffo'

alias gl="git log --no-show-signature --graph -n 1000 --format='tformat:$git_log_format'"

alias s="git status --short --branch"
alias gs="git show --show-signature"
alias gd="git diff"
alias gdw="git diff --color-words"
alias staged="gd --cached"

unset -v git_log_format
# }}}
# {{{ Job control aliases and hacks
alias j='jobs -l'

setopt auto_continue # CONT any disowned commands
setopt auto_resume   # "man" automatically resumes "man command" if in background ("man other" does not)
setopt check_jobs    # print job statuses on exit, and cancel exiting the first time
setopt hup           # HUP any jobs when exiting
# }}}
# {{{ Ruby development with Bundler / binstubs / etc.

bundle-exec () {
  if [ -f "bin/$1" ]; then
    echo "(→ bin/$*)"
    cmd=$1
    shift
    "bin/$cmd" "$@"
  elif [ -f Gemfile ]; then
    echo "(→ bundle exec $*)"
    command bundle exec "$@"
  else
    $@
  fi
}

binstub-exec() {
  if [ -f "bin/$1" ]; then
    echo "(→ bin/$*)"
    cmd=$1
    shift
    "bin/$cmd" "$@"
  else
    $@
  fi
}

alias bundle="binstub-exec bundle"

for gem in guard rspec rails rubocop rake standardrb; do
  alias $gem="bundle-exec $gem"
done

alias wer="watchexec -ce rb --"

# }}}
# {{{ Autoload functions

autoload zmv

fpath=("${XDG_CONFIG_HOME}/zsh/funcs" $fpath)

autoload seconds-to-human
autoload theme

# }}}
# {{{ Color shortcuts and magic
autoload colors
colors

function is256color() {
  if [[ $(tput colors) -ge 256 ]]; then
    true
  else
    false
  fi
}

function colortest() {
  msgcat --color=test
}
# }}}
# {{{ Prompt settings and configuration

# Make RPROMPT disappear after running a command
setopt transient_rprompt

# From the manpage:
# If  the  PROMPT_SUBST option is set, the prompt string is first subjected to
# parameter expansion, command substitution and arithmetic expansion.
# See zshexpn(1).
setopt prompt_subst

#
# Setup VCS info for the prompt
#
function() {
  if is-at-least 4.3.0; then
    autoload -Uz vcs_info

    # Speed it up by removing systems I'm not using
    zstyle ':vcs_info:*' enable git

    zstyle ':vcs_info:*:prompt:*' use-prompt-escapes true
    zstyle ':vcs_info:*:prompt:*' check-for-changes true

    zstyle ':vcs_info:*:prompt:*' unstagedstr "%1{★%}"
    zstyle ':vcs_info:*:prompt:*' stagedstr "%1{❖%}"

    local branch_format="%F{214}%b" # %b = branch

    if is-at-least 4.3.11; then
      local changes_format="%F{022}%c%F{088}%u"
    else
      # Old version cannot show changes
      local changes_format=""
    fi

    zstyle ':vcs_info:*:prompt:*' formats       "${changes_format}${branch_format}%f" ""
    zstyle ':vcs_info:*:prompt:*' actionformats "${changes_format}${branch_format}%f [%F{cyan}%a%f]" ""

    zstyle ':vcs_info:*:prompt:*' nvcsformats   "" ""

    # Generate VCS info just before rendering prompt
    function mange-prompt-precmd-vcs {
      vcs_info 'prompt'
    }
    add-zsh-hook precmd mange-prompt-precmd-vcs
  else
    export vcs_info_msg_0_="zsh too old"
  fi
}

# Convenience functions to disable/enable check-for-changes in certain sessions
function disable-check-for-changes() {
  zstyle ':vcs_info:*:prompt:*' check-for-changes false
}

function enable-check-for-changes() {
  zstyle ':vcs_info:*:prompt:*' check-for-changes true
}

#
# Helper functions to be used when building the prompt
#

# Keep track of how long a command runs for
function mange-prompt-preexec() {
  cmd_timestamp=$EPOCHSECONDS

  # shows the current dir and executed command in the title when a process is active
  (
    setopt nopromptsubst
    local terminal_title_format="$2 [%4~]"
    print -Pn "\033]0;${terminal_title_format}\007"
  )
}

# - Show time taken for long-running commands
# - Set terminal title
function mange-prompt-precmd() {
  local stop=$EPOCHSECONDS
  local start=${cmd_timestamp:-$stop}
  local elapsed=$((stop-start))
  if ((elapsed >= 10)); then
    echo -e "${bg[cyan]}${fg[black]}🕓 $(seconds-to-human $elapsed)${reset_color}${fg[cyan]}${reset_color}"
  fi
  unset cmd_timestamp

  # Set terminal title, using prompt format.
  local terminal_title_format="zsh [%4~]"
  print -Pn "\033]0;${terminal_title_format}\007"
}
add-zsh-hook preexec mange-prompt-preexec
add-zsh-hook precmd mange-prompt-precmd

# Show verbose mode information
function vi_mode_prompt_info {
  zle_mode_output "" "%K{196}%F{000} CMD %f%k"
}

# Treat these characters as having width 1
_prompt_insert_mode_character="%1{›%}"
_prompt_command_mode_character="%1{»%}"

# Show mode information by the last character in the prompt
function prompt_end_character {
  zle_mode_output "$_prompt_insert_mode_character " "%F{196}${_prompt_command_mode_character}%f "
}

#
# Actually set up the PROMPT and RPROMPT variables
#
function {
  if [[ -n $SSH_CLIENT ]]; then
    if is256color; then
      local host="%F{241}@%F{60}%4m "
    else
      local host="%f@%F{blue}%4m "
    fi
  else
    local host=""
  fi

  # Don't show user at all if it's expected username
  if [[ $USER == "mange" ]]; then
    local user=""
  else
    # Color user differently if we have a privileged user ("!")
    # %(nx.true.false)
    local user="%(!.%F{196}.%F{072})%n"
  fi

  local dir="%B%F{blue}%4~%b"
  local last_status="%(?..%F{red}🗲%? )"
  local current_jobs="%(1j.%F{magenta}🗗%B%j%b .)"
  local end='$(prompt_end_character)%f%k%b'

  export RPROMPT='$(vi_mode_prompt_info)$vcs_info_msg_0_'
  export PROMPT="${user}${host}${last_status}${current_jobs}${dir} ${end}"
}
# }}}
# {{{ Misc
# Disable flow control to allow ctrl-s and ctrl-q in terminal
stty -ixon -ixoff

# Autocompletion for Travis gem
[ -f $HOME/.travis/travis.sh ] && source $HOME/.travis/travis.sh
# }}}

# Chain with true to avoid $? being false
[ -f "${XDG_CONFIG_HOME}/zsh/zshrc.after.local" ] && source "${XDG_CONFIG_HOME}/zsh/zshrc.after.local" || true

# {{{ RVM
# shellcheck source=/dev/null
source "${XDG_CONFIG_HOME}/shells/enable-rvm"
# }}}

# {{{ Plugins
try-source-plugin zsh-syntax-highlighting || true

if try-source-plugin zsh-history-substring-search; then
  bindkey -M viins '^N' history-substring-search-up
  bindkey -M viins '^P' history-substring-search-down
  bindkey -M vicmd '^N' history-substring-search-up
  bindkey -M vicmd '^P' history-substring-search-down
fi

if command-exist fzf && [[ -f ~/.config/zsh/fzf-tab/fzf-tab.plugin.zsh ]]; then
  source ~/.config/zsh/fzf-tab/fzf-tab.plugin.zsh

  FZF_TAB_COMMAND=(
      fzf
      --ansi   # Enable ANSI color support, necessary for showing groups
      --expect='$continuous_trigger' # For continuous completion
      '--color=hl:$(( $#headers == 0 ? 108 : 255 ))'
      --nth=2,3 --delimiter='\x00'  # Don't search prefix
      --layout=reverse --height='${FZF_TMUX_HEIGHT:=75%}'
      --tiebreak=begin -m --bind=tab:down,ctrl-j:accept,change:top,ctrl-space:toggle --cycle
      '--query=$query'   # $query will be expanded to query string at runtime.
      '--header-lines=$#headers' # $#headers will be expanded to lines of headers at runtime
  )
  zstyle ':fzf-tab:*' command $FZF_TAB_COMMAND

  # disable sort when completing options of any command
  zstyle ':completion:complete:*:options' sort false

  # give a preview when completing `kill`
  zstyle ':completion:*:*:*:*:processes' command "ps -u $USER -o pid,user,comm,cmd -w -w"
  zstyle ':fzf-tab:complete:kill:argument-rest' extra-opts '--preview=echo $(<{f})' --preview-window=down:3:wrap

  # (experimental) give a preview of directory when completing cd
  local extract="
  # trim input
  in=\${\${\"\$(<{f})\"%\$'\0'*}#*\$'\0'}
  # get ctxt for current completion
  local -A ctxt=(\"\${(@ps:\2:)CTXT}\")
  "
  zstyle ':fzf-tab:complete:cd*' extra-opts --preview=$extract"exa -1 --color=always \${~ctxt[hpre]}\$in"
fi
# }}}

unset -f alias-if-exist
