#!/bin/zsh
# Useful functions

# $EDITOR: Opens $EDITOR, unless some parameter is a file owned 
# by root, in which case "sudo $EDITOR" is invoked.
# Example:
#  ~$ vim tmp.txt
#        ... edit ...
#  ~$ vim /etc/conf
#  Password:
#       ... edit ...
function $EDITOR {
	LIMIT=$#
	for ((i = 1; i <= $LIMIT; i++ )) do
		eval file="\$$i"
		if [[ -e $file && ! -O $file ]]
		then
			otherfile=1
		else
	
		fi
	done
	if [[ $otherfile = 1 ]]
	then
		sudo $EDITOR "$@"
	else
		command $EDITOR "$@"
	fi
}

# zipdir: Compresses the supplied dir into a zip, ignoring
# crap
# usage: zipdir ./release
#   (Saves to ./release.zip)
zipdir() { zip "$@".zip -r "$@" -x "*/.DS_Store" "*/.svn/*" }


# bak: Renames file to *~
# usage: bak <fname>
# example: important.sh -> important.sh~
bak() {
	mv "$1" "$1~"
}

# rmbak: Removes backup files
# usage: rmbak
rmbak() {
	rm -vf .*~ *~ \#*\#
}

# Name a directory.
# Usage:
#    namedir $name [ $path ]
# If $path is not set, the function will use the current 
# working directory instead.
#
# Please note that this is not persistent or shared
# between shells running. If you want any permanent names
# pleace place them in ~/.zsh-named-directories
#
# Example usage:
#   ~mange$ cd /var/log/apache2/myhost.com/subdomain
#   /var/log/apache2/myhost.com/subdomain$ namedir sublog
#   ~sublog$ namedir aplog /var/log/apache2
#   ~sublog$ cd ~aplog
namedir () { 
     local dir
     if [[ x$2 == x ]]; then
          dir = `pwd`
     else
          dir=$2
     fi

     hash -d $1=$dir
}

# inject_named_dirs: Try to shorten a path using named dirs
# usage:
#    ~mydir/conf % pwd
#    /home/joe/projects/mydirectory/conf
#    ~mydir/conf % inject_named_dirs `pwd`
#    ~mydir/conf
#
inject_named_dirs () {
     local d p
     d=$1
     # Go through every key in $nameddirs
     for n in ${(onk)nameddirs}; do
          p=$nameddirs[$n]
          d=$(echo $d | sed "s;$p;~$n;")
     done
     echo $d
}

# Set Konsole session name
# This function changes the session name
# in Konsole. Should be completely silent if
# the terminal is not a child of Konsole.
konsole-name () {
     # Look for a parent Konsole
     dcop konsole-$PPID &> /dev/null
     if [[ $? == "0" ]]; then
          # We are in Konsole!
          local session
          session=`dcop konsole-$PPID konsole currentSession`
          dcop konsole-$PPID $session renameSession "$1"
     fi
}

# Convert a relative path to an absolute path
# This works for both files and directories.
#
# Examples:
#  ~/docs % rel-to-abs .
#  /home/joe/docs
#  ~/docs % rel-to-abs document.odf
#  /home/joe/docs/document.odf
#
rel-to-abs() {
  local dest file
  dest=$1
  
  # If it's an absolute path already
  if [[ "$dest" == /* ]]; then
    echo $dest
    return 0
  fi
  
  # Place a "./" in the beginning in case they are not
  # there already. This will make the directory correction
  # work correctly.
  if [[ "$dest" != ./* ]]; then
    dest="./$dest"
  fi
  
  # Make sure the file/dir actually exists
  if [[ ! -e "$dest" ]]; then
      echo "'$dest' doesn't even exist, dummy!" > /dev/stderr
      return 1
  fi
  
  # Check if it's a file
  if [[ -f "$dest" ]]; then
    # A file is a bit harder... We must remove the file part from the name...
    # sed should do the job nicely!
    file="/$(echo $dest | sed 's:^.*/::')" # Delete everything except the filename
    dest=$(echo $dest | sed 's:/[^/]*$::') # Replace everything after the last /
                                           # to the end of the string   
    # /path/to/file
    #         |----|
    #      Will be removed
  fi
  
  echo $(cd "$dest"; pwd)$file
}