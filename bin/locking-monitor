#!/usr/bin/env bash
# Runs in the background and keeps track of when the user's session is
# locked/unlocked. When a locking event happens the appropriate script runs.

if [[ -z "$XDG_SESSION_ID" ]]; then
  echo "ERROR: No \$XDG_SESSION_ID value present!" > /dev/stderr
  exit 2
fi

interface=org.freedesktop.login1.Session
session="/org/freedesktop/login1/session/$XDG_SESSION_ID"
matcher="type=signal,path=${session},interface=${interface}"

lock_script="${XDG_CONFIG_HOME}/locking-monitor/on_lock"
unlock_script="${XDG_CONFIG_HOME}/locking-monitor/on_unlock"

# Emits signals that look like this: (Line breaks added for readability)
# signal time=1530687734.989902 sender=:1.3 ->
#    destination=(null destination)
#    serial=1403
#    path=/org/freedesktop/login1/session/c2;
#    interface=org.freedesktop.login1.Session;
#    member=Lock
dbus-monitor --system "$matcher" 2>/dev/null |
  # Extract the "member=SomeMember" part as "SomeMember"
  # Grep defaults to buffering up all output until the input stream is closed
  # when grep's stdout isn't a terminal, --line-buffered goes back to the same
  # line-by-line behavior that it uses when the output is a terminal.
  grep --line-buffered -oP '(?<=member=)\w+' |
  while read -r member; do
    case "$member" in
      Lock)
        if [[ -x "$lock_script" ]]; then
          "$lock_script"
        fi
        ;;
      Unlock)
        if [[ -x "$unlock_script" ]]; then
          "$unlock_script"
        fi
        ;;
      *)
        # Do nothing on unexpected signals
    esac
  done
