#!/usr/bin/env bash

# shellcheck source=/home/mange/.config/shells/common
source "${HOME}/.config/shells/common"

mbsync_config="${XDG_CONFIG_HOME:-$HOME/.config}/isync/mbsyncrc"
mail_dir="$HOME/Mail"

readarray -t mailboxes < \
  <(
    find "${mail_dir}/" \
      -mindepth 1 -maxdepth 1 \
      -not -name '.*' \
      -type d \
      -exec basename "{}" ";"
  )

print_usage() {
  cat <<USAGE
Usage: $(basename "$0") [options] <commands…>

Options:
  --help  - Show this help and exit

Commands:
  list [--no-names]
    List mailboxes.

  sync [mailbox]
    Sync selected or all mailboxes, updating status during the sync.

  status [--refresh] [mailbox]
    Show current status or all, or selected mailbox. Optionally refresh status
    instead of reading cached status.

  help
    Show this help and ext.
USAGE
}

perform_list() {
  local show_names="yes"
  [[ "$1" == "--no-names" ]] && show_names="no"

  for box in "${mailboxes[@]}"; do
    if [[ $show_names == "yes" ]]; then
      echo "${box} - $(get_box_name "$box")"
    else
      echo "${box}"
    fi
  done
}

perform_sync() {
  local box="$1"

  if [[ -n $box ]]; then
    perform_box_sync "$box"
  else
    for box in "${mailboxes[@]}"; do
      perform_box_sync "$box"
    done
  fi
}

perform_box_sync() {
  local box="$1"
  local lockfile="${mail_dir}/${box}/.mailboxes-lock"
  local name
  name="$(get_box_name "$box")"

  echo "= ${name} ="

  if aquire_lock "$lockfile"; then
    unread_before="$(write_status "$box" "痢")"

    # Initial index makes sure that changes made locally will be applied to the
    # server when it is finally synced.
    echo "Indexing local messages"
    index_and_tag_emails "$box"

    echo "Syncing with remote"
    verbose mbsync --config "$mbsync_config" "$box"

    # Then index again in case any new messages were downloaded from the
    # server, or emails were moved server-side before the sync started.
    echo "Indexing messages again"
    index_and_tag_emails "$box"

    unread_after="$(write_status "$box")"
    new_email=$((unread_after - unread_before))
    if [[ $new_email -gt 0 ]]; then
      notify-send \
        --icon /usr/share/icons/oxygen/base/32x32/actions/mail-message-new.png \
        --urgency low \
        --category email.arrived \
        --app-name "mailboxes" \
        "New email in ${name}" \
        "You have ${new_email} new email(s) in ${name}. Total unread is ${unread_after}."
    fi

    unlock "$lockfile"
  fi
}

index_and_tag_emails() {
  local box="$1"

  # Index new emails…
  verbose notmuch new
  # …and auto-tag them
  verbose afew --tag --new --verbose

  # Emails that are no longer in inbox should get the inbox tag removed
  verbose notmuch tag -inbox -- "path:${box}/**" AND tag:inbox AND NOT "path:${box}/inbox/**"

  # Move files on disk to match their tags. This enables the changes to be
  # synced to the server.
  verbose afew --move --verbose
}

perform_status() {
  local box
  local refresh=no

  while [[ -n "$1" ]]; do
    case "$1" in
      "--refresh")
        refresh=yes
        shift
        ;;
      -*)
        die "Unrecognized status option: $1"
        ;;
      *)
        break
        ;;
    esac
  done

  if [[ -n $box ]]; then
    if [[ $refresh == yes ]]; then
      write_status "$box" >/dev/null
    fi
    read_status "$box"
  else
    for box in "${mailboxes[@]}"; do
      if [[ $refresh == yes ]]; then
        write_status "$box" >/dev/null
      fi
      echo -n "$(get_box_name "$box"): "
      read_status "$box"
    done
  fi
}

read_status() {
  local box="$1"
  local statefile="${mail_dir}/${box}/.mailboxes-state"

  if [[ -f "$statefile" ]]; then
    cat "${mail_dir}/${box}/.mailboxes-state"
  else
    echo ""
  fi
}

aquire_lock() {
  local path="$1"

  if [[ -f "$path" ]]; then
    echo "Lockfile present. Aborting."
    return 1
  else
    echo "" > "$path"
    return 0
  fi
}

unlock() {
  local path="$1"
  # Just to be very very sure here
  if [[ "$path" == *-lock ]]; then
    rm -r "$path"
  else
    die "That does not look like a lockfile to me: ${path}"
  fi
}

write_status() {
  local box="$1"
  local icon="$2"
  local message
  local unread_important
  local unread_all
  unread_important="$(count_email_inbox "$box" tag:important AND tag:unread)"
  unread_all="$(count_email_inbox "$box" tag:unread)"
  message="${icon:-} ${unread_important}:${unread_all}"

  echo "$message" > "${mail_dir}/${box}/.mailboxes-state"
  (set +e; polybar-msg hook mailboxes 1 >/dev/null 2>/dev/null)
  echo "$unread_important"
}

count_email_inbox() {
  local box="$1"
  shift
  notmuch count --output=threads "folder:${box}/inbox" AND "$@"
}

get_box_name() {
  local box="$1"

  if [[ -f "${mail_dir}/${box}/.mailboxes-name" ]]; then
    cat "${mail_dir}/${box}/.mailboxes-name"
  else
    echo "$box"
  fi
}

verbose() {
  if [[ -t 2 ]]; then
    echo -e "\e[37m# ${*}\e[0m" >&2
  else
    echo "$@" >&2
  fi

  "$@"
}

die() {
  echo "$@" >&2
  exit 1
}

while [[ -n "$1" ]]; do
  case "$1" in
    --help | help)
      print_usage
      exit 0
      ;;
    list)
      shift
      perform_list "$@"
      exit 0
      ;;
    sync)
      shift
      perform_sync "$@"
      exit 0
      ;;
    status)
      shift
      perform_status "$@"
      exit 0
      ;;
    *)
      echo "Unknown option \"$1\"" >&2
      print_usage >&2
      exit 1
  esac
done
