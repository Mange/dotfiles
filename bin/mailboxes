#!/usr/bin/env bash

# shellcheck source=/home/mange/.config/shells/common
source "${HOME}/.config/shells/common"

mbsync_config="${XDG_CONFIG_HOME:-$HOME/.config}/isync/mbsyncrc"
mail_dir="$HOME/Mail"

if [[ -f ~/Mail/list ]]; then
  readarray -t mailboxes < ~/Mail/list
else
  readarray -t mailboxes < \
    <(
      find "${mail_dir}/" \
        -mindepth 1 -maxdepth 1 \
        -not -name '.*' \
        -type d \
        -exec basename "{}" ";"
    )
fi

print_usage() {
  cat <<USAGE
Usage: $(basename "$0") [options] <commands…>

Options:
  --help  - Show this help and exit

Commands:
  list [--no-names]
    List mailboxes.

  sync [mailbox...]
    Sync selected or all mailboxes, updating status during the sync.

  status [--refresh] [--] [mailbox...]
    Show current status or all, or selected mailbox(es). Optionally refresh
    status instead of reading cached status.

  help
    Show this help and ext.
USAGE
}

perform_list() {
  local show_names="yes"
  [[ "$1" == "--no-names" ]] && show_names="no"

  for box in "${mailboxes[@]}"; do
    if [[ $show_names == "yes" ]]; then
      echo "${box} - $(get_box_name "$box")"
    else
      echo "${box}"
    fi
  done
}

perform_sync() {
  local box
  local boxes

  while [[ -n "$1" ]]; do
    case "$1" in
      --)
        shift
        break
        ;;
      -*)
        die "Unrecognized status option: $1"
        ;;
      *)
        break
        ;;
    esac
  done

  if [[ $# -gt 0 ]]; then
    boxes=( "$@" )
  else
    boxes=( "${mailboxes[@]}" )
  fi

  for box in "${boxes[@]}"; do
    ensure_valid_box "$box"
    perform_box_sync "$box"
  done
}

perform_box_sync() {
  local box="$1"
  local lockfile="${mail_dir}/${box}/.mailboxes-lock"
  local name
  local lock_fd
  name="$(get_box_name "$box")"

  echo "= ${name} ="

  exec {lock_fd}>"$lockfile"
  flock -n "$lock_fd" || { echo "Lock present. Aborting." >&2; return 0; }
  unread_before="$(write_status "$box" "痢")"

  # Initial index makes sure that changes made locally will be applied to the
  # server when it is finally synced.
  echo "Indexing local messages"
  index_and_tag_emails "$box"

  echo "Syncing with remote"
  verbose mbsync --config "$mbsync_config" "$box"

  # Then index again in case any new messages were downloaded from the
  # server, or emails were moved server-side before the sync started.
  echo "Indexing messages again"
  index_and_tag_emails "$box"

  unread_after="$(write_status "$box")"
  new_email=$((unread_after - unread_before))
  if [[ $new_email -gt 0 ]]; then
    notify-send \
      --icon /usr/share/icons/oxygen/base/32x32/actions/mail-message-new.png \
      --urgency low \
      --category email.arrived \
      --app-name "mailboxes" \
      "New email in ${name}" \
      "You have ${new_email} new email(s) in ${name}. Total unread is ${unread_after}."
  fi

  flock -u "$lock_fd"
}

index_and_tag_emails() {
  local box="$1"

  # Index new emails…
  verbose notmuch new
  # …and auto-tag them
  verbose afew --tag --new --verbose

  # Emails that are no longer in inbox should get the inbox tag removed
  verbose notmuch tag -inbox -- "path:${box}/**" AND tag:inbox AND NOT "path:${box}/inbox/**"

  # Move files on disk to match their tags. This enables the changes to be
  # synced to the server.
  verbose afew --move --verbose
}

perform_status() {
  local box
  local boxes
  local refresh=no

  while [[ -n "$1" ]]; do
    case "$1" in
      "--refresh")
        refresh=yes
        shift
        ;;
      --)
        shift
        break
        ;;
      -*)
        die "Unrecognized status option: $1"
        ;;
      *)
        break
        ;;
    esac
  done

  if [[ $# -gt 0 ]]; then
    boxes=( "$@" )
  else
    boxes=( "${mailboxes[@]}" )
  fi

  for box in "${boxes[@]}"; do
    ensure_valid_box "$box"
    if [[ $refresh == yes ]]; then
      write_status "$box" >/dev/null
    fi
    echo -n "$(get_box_name "$box"): "
    read_status "$box"
  done
}

ensure_valid_box() {
  local box="$1"

  if ! [[ -d "${mail_dir}/${box}" ]]; then
    die "Not a valid mailbox: $box"
  fi
}

read_status() {
  local box="$1"
  local statefile="${mail_dir}/${box}/.mailboxes-state"

  if [[ -f "$statefile" ]]; then
    cat "${mail_dir}/${box}/.mailboxes-state"
  else
    echo ""
  fi
}

write_status() {
  local box="$1"
  local icon="$2"
  local message
  local unread_important
  local unread_all
  unread_important="$(count_email_inbox "$box" tag:important AND tag:unread)"
  unread_all="$(count_email_inbox "$box" tag:unread)"
  message="${icon:-} ${unread_important}:${unread_all}"

  echo "$message" > "${mail_dir}/${box}/.mailboxes-state"
  # TODO: Trigger awesome wibar to reload widget
  echo "$unread_important"
}

count_email_inbox() {
  local box="$1"
  shift
  notmuch count --output=threads "folder:${box}/inbox" AND "$@"
}

get_box_name() {
  local box="$1"

  if [[ -f "${mail_dir}/${box}/.mailboxes-name" ]]; then
    cat "${mail_dir}/${box}/.mailboxes-name"
  else
    echo "$box"
  fi
}

verbose() {
  if [[ -t 2 ]]; then
    echo -e "\e[37m# ${*}\e[0m" >&2
  else
    echo "$@" >&2
  fi

  "$@"
}

die() {
  echo "$@" >&2
  exit 1
}

while [[ -n "$1" ]]; do
  case "$1" in
    --help | help)
      print_usage
      exit 0
      ;;
    list)
      shift
      perform_list "$@"
      exit 0
      ;;
    sync)
      shift
      perform_sync "$@"
      exit 0
      ;;
    status)
      shift
      perform_status "$@"
      exit 0
      ;;
    *)
      echo "Unknown option \"$1\"" >&2
      print_usage >&2
      exit 1
  esac
done
